from odoo import models, api

class BudgetQueryExecutor(models.AbstractModel):
    _name = "ai.budget.executor"
    _description = "Executes budget queries generated by AI"

    @api.model
    def _domain_for_year_and_type(self, year, dep_type):
        domain = [
            ('date_from', '<=', f'{year}-12-31'),
            ('date_to', '>=', f'{year}-01-01'),
        ]
        if dep_type and dep_type != 'any':
            domain.append(
                ('crossovered_budget_id.type_budget', '=', dep_type)
            )
        return domain

    @api.model
    def execute(self, instruction):
        BudgetLine = self.env['crossovered.budget.lines']

        action = instruction.get('action')
        dep_type = instruction.get('type', 'any')
        year = instruction.get('year')

        if action in ('sum', 'list', 'top') and not year:
            raise ValueError("year is required")

        if action == 'sum':
            domain = self._domain_for_year_and_type(year, dep_type)
            lines = BudgetLine.search(domain)

            total_prev = sum(l.montant_prev or 0.0 for l in lines)
            total_real = sum(l.montant_realise or 0.0 for l in lines)

            pct = (total_real / total_prev * 100) if total_prev else None

            return {
                'year': year,
                'type': dep_type,
                'montant_prev': total_prev,
                'montant_real': total_real,
                'pourcentage_realisation': pct,
            }

        elif action == 'list':
            domain = self._domain_for_year_and_type(year, dep_type)
            lines = BudgetLine.search(domain)

            return {
                'lines': [{
                    'budget': l.crossovered_budget_id.name,
                    'type_budget': l.crossovered_budget_id.type_budget,
                    'position_budgetaire': (
                        l.general_budget_id.name
                        if l.general_budget_id else None
                    ),
                    'montant_prev': l.montant_prev,
                    'montant_realise': l.montant_realise,
                    'date_from': l.date_from,
                    'date_to': l.date_to,
                } for l in lines]
            }

        elif action == 'compare':
            year2 = instruction.get('year_compare')
            if not year2:
                raise ValueError("year_compare required")

            dom1 = self._domain_for_year_and_type(year, dep_type)
            dom2 = self._domain_for_year_and_type(year2, dep_type)

            l1 = BudgetLine.search(dom1)
            l2 = BudgetLine.search(dom2)

            return {
                'year_1': year,
                'year_2': year2,
                'montant_prev_1': sum(l.montant_prev or 0 for l in l1),
                'montant_prev_2': sum(l.montant_prev or 0 for l in l2),
                'montant_real_1': sum(l.montant_realise or 0 for l in l1),
                'montant_real_2': sum(l.montant_realise or 0 for l in l2),
            }

        elif action == 'top':
            limit = instruction.get('limit') or 5
            domain = self._domain_for_year_and_type(year, dep_type)

            lines = BudgetLine.search(
                domain, order="montant_prev desc", limit=limit
            )

            return {
                'top_lines': [{
                    'budget': l.crossovered_budget_id.name,
                    'position_budgetaire': (
                        l.general_budget_id.name
                        if l.general_budget_id else None
                    ),
                    'montant_prev': l.montant_prev,
                    'montant_realise': l.montant_realise,
                } for l in lines]
            }

        raise ValueError(f"Unknown action: {action}")
